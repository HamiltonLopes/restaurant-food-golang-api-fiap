// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package fiapRestaurantDb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllOrders = `-- name: GetAllOrders :many
WITH paginated_orders AS (
    SELECT DISTINCT ON (o.id) o.id, o.created_at
    FROM orders o
    WHERE o.deleted_at IS NULL
    LIMIT $1
    OFFSET $2
)
select o.id         as order_id,
       o.created_at as order_created_at,
       o.updated_at as order_updated_at,
       o.status     as order_status,
       c.name       as client_name,
       c.cpf as client_cpf,
       c.id         as client_id,
       p.id         as product_id,
       p.name       as product_name,
       p.price      as product_price,
       p.description as product_description,
       oi.quantity  as product_quantity,
       py.id as payment_id,
       py.status as payment_status,
       py.amount as payment_amount,
       py.method as payment_method,
       pt.handle    as category_handle
from paginated_orders po 
         join orders o on o.id = po.id
         join order_items oi on oi.order_id = o.id
         join products p on oi.product_id = p.id
         join categories pt on p.category_id = pt.id
         join payments py on py.order_id = o.id
         join clients c on c.id = o.client_id
WHERE o.deleted_at IS NULL
ORDER BY o.created_at DESC
`

type GetAllOrdersParams struct {
	Limit  int32
	Offset int32
}

type GetAllOrdersRow struct {
	OrderID            int32
	OrderCreatedAt     pgtype.Timestamp
	OrderUpdatedAt     pgtype.Timestamp
	OrderStatus        pgtype.Text
	ClientName         string
	ClientCpf          string
	ClientID           int32
	ProductID          int32
	ProductName        string
	ProductPrice       pgtype.Numeric
	ProductDescription string
	ProductQuantity    int32
	PaymentID          int32
	PaymentStatus      pgtype.Text
	PaymentAmount      pgtype.Numeric
	PaymentMethod      string
	CategoryHandle     pgtype.Text
}

func (q *Queries) GetAllOrders(ctx context.Context, arg GetAllOrdersParams) ([]GetAllOrdersRow, error) {
	rows, err := q.db.Query(ctx, getAllOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOrdersRow
	for rows.Next() {
		var i GetAllOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.OrderCreatedAt,
			&i.OrderUpdatedAt,
			&i.OrderStatus,
			&i.ClientName,
			&i.ClientCpf,
			&i.ClientID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductDescription,
			&i.ProductQuantity,
			&i.PaymentID,
			&i.PaymentStatus,
			&i.PaymentAmount,
			&i.PaymentMethod,
			&i.CategoryHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
